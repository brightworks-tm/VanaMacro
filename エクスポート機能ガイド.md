
# エクスポート機能ガイド

## 背景と課題
- 現状 UI は `macros/macros_<character_id>.json` を編集し、`MacroRepository` 経由で永続化している（`model.py`）。
- FFXI 形式 (USER/<ID>/mcr*.dat, mcr.ttl, mcr_2.ttl) への逆変換ロジックは未実装で、`ffxi_mcr.py` も読み込み専用（`parse_mcr_dir` のみ）。
- そのため `/data/edit` にあるバックアップから UI で編集した内容をゲームへ戻すには、ユーザーが外部ツールで mcr*.dat に書き戻す必要がある。
- 「外部編集 → UI で調整 → FFXI へ反映」の一連のワークフローをアプリ内で完結させるため、書き戻しの仕様と実装が必要。

## 目標
1. MacroRepository の状態から mcr*.dat / mcr.ttl / mcr_2.ttl を正しいバイト構造で生成できるシリアライザを提供する。
2. `/data/edit/<CharacterID>` から出て `/data/export/<CharacterID>/<timestamp>` に戻ってくるストーリーを整備する。
3. 必要に応じて FFXI の USER フォルダへ直接書き戻す／Zip で配布するなど別ルートを選択できるようにする。
4. 書き出したファイルを再パース (`ffxi_mcr.parse_mcr_dir`) して diff 検証する自動テストを用意し、双方向同等性を担保する。

## 関連コードの整理
- `ffxi_mcr.py` (`_read_set_file`, `parse_mcr_dir`) … mcr*.dat と mcr.ttl を読み込み、JSON 互換の辞書に変換する。シリアライズでも同じオフセット計算を再利用する予定。
- `model.py` … `MacroRepository` が 40x10x(10x2) のマクロ状態を保持。保存先は `macros/macros_<character_id>.json`。
- `storage.py` … `DATA_ROOT`、`EDIT_ROOT` などのルート定義がある。ここに `EXPORT_ROOT = DATA_ROOT / "export"` を追加するイメージ。
- `ffxi_autotrans.py` … ショートカット語句の復号のみ提供している。エンコード処理を追加し、シリアライズ時でも << >> 記法を FFXI のトークンへ戻せるようにする必要がある。

## 実装構成案
### 1. バイナリシリアライザ (`ffxi_mcr_writer.py`)
1. `encode_macro_line(text: str) -> bytes`  
   - `cp932` で 60 byte に丸め、末尾に `0x00` を付与して 61 byte 固定。`<<>>` の自動翻訳語句は `ffxi_autotrans` に追加したエンコーダで 6 byte トークンへ置換。
2. `encode_macro_name(name: str) -> bytes`  
   - 全角 4 文字（8 byte）まで `cp932` で詰め、足りない分は `0x00` パディング。
3. `serialize_set(set_data, template_bytes: Optional[bytes]) -> bytes`  
   - 1 ファイル 7624 byte 固定。`ctrl/alt` × 10 スロットを `key_index`／`slot` でループし、各マクロ 380 byte を書き換える。  
   - 先頭 24 byte および各ブロック頭の 4 byte など未知領域は `template_bytes`（既存ファイル）をベースに保持。無ければゼロ埋めのテンプレートを生成。
4. `serialize_book_titles(titles: List[str]) -> Tuple[bytes, bytes]`  
   - `mcr.ttl` に book0-19、`mcr_2.ttl` に book20-39 を収容。ファイルは 16 byte のヘッダ + 20 エントリ * 16 byte。各エントリ後半 8 byte にタイトルを書く。
5. `write_macro_repository(repository: MacroRepository, dest_folder: Path, source_folder: Optional[Path])`  
   - `source_folder`（通常 `/data/edit/<CharacterID>`）を読むことでテンプレートを取得。  
   - 400 個の mcr*.dat と 2 個の ttl ファイルを全て書き出し、`manifest.json`（エクスポート時刻、元 JSON のパス、比較用ハッシュ等）も保存。

### 2. オートトランスレータのエンコード
- `ffxi_autotrans.py` に逆引き辞書を用意する。`_load_general_dictionary` 等で取得したマップを text -> token に反転してキャッシュ。
- `encode_macro_text(text: str) -> bytes` を追加し、`decode_macro_text` と対称 API を提供。  
  - `<<>>` ブロックを見つけ次第 token に変換、通常文字列は `cp932` でそのまま。
- これにより `Macro.lines` を JSON で編集した後も FFXI と互換のバイト列を再構成可能になる。

### 3. エクスポートオーケストレーション (`exporter.py` 想定)
1. `ensure_export_root()` で `data/export/<CharacterID>` を作成。
2. トリガ: UI の「エクスポート」ボタン or CLI `python main.py export <CharacterID>`.
3. `MacroRepository.load_or_create` で最新 JSON を読み込み → `ffxi_mcr_writer.write_macro_repository`.
4. 実行ログ（stdout, `export.log`）に書き出したパス一覧を出力し、UI にも通知。
5. オプションで `storage.ffxi_user_root()` 配下へコピーする「直接反映モード」を用意し、UAC が必要な Program Files 直下は極力避ける（My Documents 優先）。

## ディレクトリ構成イメージ
```
data/
  edit/<CharacterID>/mcr*.dat, mcr.ttl, mcr_2.ttl     ← 入力テンプレート
  export/
    <CharacterID>/
      YYYYMMDD_HHMMSS/
        mcr.dat ... mcr399.dat
        mcr.ttl
        mcr_2.ttl
        manifest.json
        macros_<CharacterID>.json (エクスポート時点のスナップショット)
```
- `manifest.json` 例: `{ "character_id": "test_export", "source_json": "macros/macros_test_export.json", "exported_at": "...", "files": {...}}`
- UI では最新のエクスポートフォルダを一覧表示し、クリックでエクスプローラを開けるようにする。

## 処理フロー詳細
1. `MacroRepository.save` は従来通り JSON のみを更新（上書き頻度が高いため）。  
   書き戻しはユーザーが明示的にエクスポートしたときだけ実行する。
2. エクスポートを開始すると、
   1. `/data/export/<CharacterID>` に時刻付きフォルダを作成。
   2. `/data/edit/<CharacterID>`、`FFXI_USER` の順にテンプレートを探索。
   3. `ffxi_mcr_writer` が 400 個の mcr*.dat を生成（必要に応じて並列化も可）。
   4. `mcr.ttl` / `mcr_2.ttl` に book 名を出力（`MacroBook.name` 参照）。空の場合は `0x00` 埋め。
   5. エクスポート結果を `ffxi_mcr.parse_mcr_dir()` で再パースして JSON と diff → 差異があればログに警告。
3. UI/CLI は結果パスを返し、ユーザーが FFXI USER フォルダへ手動コピーできる。

## バイナリ仕様 (メモ)
### mcr*.dat
- ファイルサイズ 7,624 byte 固定（`ffxi_mcr.py` の `_set_filename`, `_read_set_file` を参照）。
- 先頭 24 byte: 不明領域。元ファイルがあればそのまま複製。
- `ctrl` 側 3,800 byte (`10 macro * 380`)、`alt` も同サイズ。計 24 + 3,800 * 2 = 7,624。
- 各マクロ (380 byte):
  - 0-3 byte: 未使用/予約（テンプレート維持）。
  - 4-369 byte: 6 行 * 61 byte。各行 = 60 byte 有効データ + 0x00 ターミネータ。
  - 370-377 byte: マクロ名 (8 byte = 4 文字上限)。`ffxi_mcr.py` では `[:4]`。
  - 378-379 byte: 不明/予約。
- 文字列は `cp932` で書き込む。`/` や `\` を含む場合も 60 byte 超を切り詰める。

### mcr.ttl / mcr_2.ttl
- 先頭 16 byte: ヘッダ（テンプレート維持）。
- 以降 20 エントリ * 16 byte。各エントリ後半 8 byteが Book 名。  
  → book0-19 を `mcr.ttl`, book20-39 を `mcr_2.ttl` に記録。
- FFXI クライアントは 8 byte を `cp932` で解釈するため、4 全角/8 半角まで。

## 別ルート（オプション）の提案
1. **直接反映モード**  
   - エクスポート後に `storage.ffxi_user_root()`（`My Documents\My Games\FINAL FANTASY XI\USER` など）へコピーする。  
   - Program Files 直下 (`FFXI_USR_ROOT`) へ書き込む場合は権限確認ダイアログを出し、`shutil.copy2` 前にバックアップを取得。
2. **Zip パッケージ出力**  
   - `data/export/<CharacterID>/<timestamp>.zip` を併せて作成し、同梱の `README_export.txt` に配置手順を記載。  
   - Discord 等で共有して別 PC の USER フォルダへ展開する用途を想定。
3. **CLI/スクリプト連携**  
   - `python main.py push <CharacterID> --target ffxi_usr` のようなコマンドで、Windower/Ashita の起動スクリプトから呼べるようにする。  
   - もしくは `watchdog` で `macros_*.json` の変更を検知し、自動的に最新エクスポートを更新 → 同期ツール（OneDrive 等）で共有する。

## テストと検証
1. シリアライズ → 即パース → JSON diff で 100% 一致するかを `pytest` で確認。
2. 実ファイル (`data/backup/...`) を fixture にし、行の長さ制限・オートトランス語句が正しく round-trip するかを確認。
3. `export` 実行後のフォルダ構成、`manifest` の内容を snapshot テスト。
4. UI からの操作は `QTest` でダイアログ遷移を確認（時間があれば）。

## 今後の TODO
- [ ] `ffxi_autotrans` にエンコーダを追加し、ユニットテストで encode/decode の逆変換を保証。
- [ ] `ffxi_mcr_writer` を実装して `MacroRepository` から直接呼べる API を公開。
- [ ] `storage.py` に `EXPORT_ROOT` / `ensure_export_root()` / `character_export_folder()` を追加。
- [ ] UI と CLI に「エクスポート」「直接反映」アクションを実装。
- [ ] `README.md` / `検証結果報告.md` で手順書を更新。
